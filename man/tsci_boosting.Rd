% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tsci_boosting.R
\name{tsci_boosting}
\alias{tsci_boosting}
\title{Two Stage Curvature Identification with Boosting.}
\usage{
tsci_boosting(
  Y,
  D,
  Z,
  X,
  vio_space = NULL,
  intercept = TRUE,
  split_prop = 2/3,
  nrounds = NULL,
  eta = NULL,
  max_depth = NULL,
  subsample = NULL,
  colsample_bytree = NULL,
  early_stopping = NULL,
  nfolds = 10,
  str_thol = 10,
  alpha = 0.05,
  parallel = "no",
  nsplits = NULL,
  mult_split_method = NULL,
  ncores = 1,
  cl = NULL
)
}
\arguments{
\item{Y}{outcome with dimension n by 1}

\item{D}{treatment with dimension n by 1}

\item{Z}{instrument variable with dimension n by 1}

\item{X}{baseline covariates with dimension n by p}

\item{vio_space}{a matrix or a list. If a matrix, then each column corresponds to a violation form of Z; If a list, then each element corresponds to a violation form of Z and must be a matrix of n rows, e.g. (Z^3,Z^2); If NULL, then default by the n by 3 matrix (Z^3, Z^2, Z). Violation form selection will be performed according to provided violation forms, for example, null violation space vs Z vs (Z^2, Z) vs (Z^3, Z^2, Z) in the default case}

\item{intercept}{logic, including the intercept or not in the outcome model, default by TRUE}

\item{split_prop}{numeric, proportion of observations used to fit the outcome model.}

\item{nrounds}{numeric, hyperparameter of the boosting algorithm. Specifies the number of boosting iterations.}

\item{eta}{numeric, hyperparameter of the boosting algorithm. Specifies the learning rate.}

\item{max_depth}{numeric, hyperparameter of the boosting algorithm. Specifies the maximal depth of each tree.}

\item{subsample}{numeric, hyperparameter of the boosting algorithm. Specifies proportion of observations used to fit each tree.}

\item{colsample_bytree}{numeric, hyperparameter of the boosting algorithm. Specifies proportion of variables used to fit each tree.}

\item{early_stopping}{logical, hyperparameter of the boosting algorithm. If \code{TRUE} early stopping will be applied.}

\item{nfolds}{numeric, the number of folds for the k-fold cross validation.}

\item{str_thol}{minimal value of the threshold of IV strength test, default by 10}

\item{alpha}{the significance level, default by 0.05}

\item{parallel}{One out of \code{"no"}, \code{"multicore"}, or \code{"snow"} specifying the parallelization method used.}

\item{nsplits}{numeric, number of times the data will be split.}

\item{mult_split_method}{method to for inference if multi-splitting is performed. Either 'DML' or 'FWER'.}

\item{ncores}{numeric, the number of cores used if multi_splitting is \code{TRUE}. \code{mclapply} form the package \code{parallel} will be called. Parallelization is not supported for Windows.}

\item{cl}{Either an parallel or snow cluster or \code{NULL}.}
}
\value{
\describe{
\item{\code{Coef_all}}{a series of point estimators of treatment effect corresponding to different violation spaces and the OLS.}
\item{\code{sd_all}}{standard errors of Coef_all.}
\item{\code{CI_all}}{confidence intervals for the treatment effect corresponding to different violation spaces and the OLS.}
\item{\code{Coef_robust}}{the point estimators corresponding to the violation space selected by the robust comparison.}
\item{\code{sd_robust}}{the standard errors of Coef_robust.}
\item{\code{CI_robust}}{confidence intervals for the treatment effect with the violation space selected by the robust comparison.}
\item{\code{iv_str}}{IV strength corresponding to different violation spaces.}
\item{\code{iv_thol}}{the threshold of IV strength test corresponding to different violation spaces.}
\item{\code{Qmax}}{the index of largest violation space selected by IV strength test. If -1, the IV strength test fails for null violation space and run OLS. If 0, the IV Strength test fails for the null violation space and run TSRF only for null violation space. In other cases, violation space selection is performed.}
\item{\code{q_hat}}{the index of estimated violation space corresponding to Qmax.}
\item{\code{invalidity}}{invalidity of TSLS. If TRUE, the IV is invalid; Otherwise, the IV is valid.}
}
}
\description{
This function implements Two Stage Curvature Identification with the Boosting. It tests the IV strength and chooses the best violation form, and also constructs the confidence interval for the treatment effect with the selected violation form.
}
\examples{
# dimension
p = 10
# sample size
n = 1000
# interaction value
inter.val = 1
# the IV strength
a = 1
# violation strength
tau = 1
f = function(x){a*(1*sin(2*pi*x) + 1.5*cos(2*pi*x))}
rho1=0.5
# function to generate covariance matrix
A1gen=function(rho,p){
  A1=matrix(0,p,p)
  for(i in 1:p){
    for(j in 1:p){
      A1[i,j]=rho^(abs(i-j))
    }
  }
  A1
}
Cov=(A1gen(rho1,p+1))
mu=rep(0,p+1)
# true effect
beta=1
alpha=as.matrix(rep(-0.3,p))
gamma=as.matrix(rep(0.2,p))
inter=as.matrix(c(rep(inter.val,5),rep(0,p-5)))


# generate the data
mu.error=rep(0,2)
Cov.error=matrix(c(1,0.5,0.5,1),2,2)
Error=MASS::mvrnorm(n, mu.error, Cov.error)
W.original=MASS::mvrnorm(n, mu, Cov)
W=pnorm(W.original)
# instrument variable
Z=W[,1]
# baseline covariates
X=W[,-1]
# generate the treatment variable D
D=f(Z)+X\%*\%alpha+Z*X\%*\%inter+Error[,1]
# generate the outcome variable Y
Y=D*beta+tau*Z+X\%*\%gamma+Error[,2]


# Two Stage Random Forest
output.BO = tsci_boosting(Y,D,Z,X)
# point estimates
output.BO$Coef_robust
# standard errors
output.BO$sd_robust
# confidence intervals
output.BO$CI_robust
}
